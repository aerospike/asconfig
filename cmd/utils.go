package cmd

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	asConf "github.com/aerospike/aerospike-management-lib/asconfig"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"

	"github.com/aerospike/asconfig/conf/metadata"
)

const (
	// outputFilePermissions defines the default file permissions for output files.
	outputFilePermissions   = 0o600
	metaKeyAerospikeVersion = "aerospike-server-version"
	metaKeyAsconfigVersion  = "asconfig-version"
	metaKeyAsadmVersion     = "asadm-version"
)

var (
	errTooManyArguments            = fmt.Errorf("expected a maximum of %d arguments", convertArgMax)
	errFileNotExist                = errors.New("file does not exist")
	errMissingAerospikeVersion     = errors.New("missing required flag '--aerospike-version'")
	errInvalidAerospikeVersion     = errors.New("aerospike version must be in the form <a>.<b>.<c>")
	errUnsupportedAerospikeVersion = errors.New("aerospike version unsupported")
	errInvalidFormat               = errors.New("invalid format flag")
	errMissingFormat               = errors.New("missing format flag")

	errDiffConfigsDiffer                = errors.New("configuration files are not equal")
	errMismatchedFileFormats            = errors.New("mismatched file formats")
	errUnableToCreateClientPolicy       = errors.New("unable to create client policy")
	errUnableToParseGeneratedServerConf = errors.New("unable to parse the generated server conf")
	errUnableToGenerateConfigFromServer = errors.New("unable to generate config from server")
	errUnableToMarshalServerConfig      = errors.New("unable to marshal server config")
	errUnableToParseServerConfigBytes   = errors.New("unable to parse server config bytes")
	errDiffTooFewArgs                   = fmt.Errorf("diff requires atleast %d file paths as arguments", diffArgMin)
	errDiffTooManyArgs                  = fmt.Errorf(
		"diff requires no more than %d file paths as arguments",
		diffArgMax,
	)
	errDiffServerTooFewArgs = fmt.Errorf(
		"diff with --server requires exactly %d file path as argument",
		diffServerArgMin,
	)
	errDiffServerTooManyArgs = fmt.Errorf(
		"diff with --server requires no more than %d file path as argument",
		diffServerArgMax,
	)

	errUnableToGenerateConfigFile       = errors.New("unable to generate config file")
	errUnableToParseGeneratedConfFile   = errors.New("unable to parse the generated conf file")
	errUnableToMarshalGeneratedConfFile = errors.New("unable to marshal the generated conf file")

	errInvalidLogLevel = errors.New("invalid log-level flag")

	errValidateTooManyArguments = fmt.Errorf("expected a maximum of %d arguments", convertArgMax)

	errMetadataDoesNotContain = errors.New("metadata does not contain key")
)

// LoggingEnum is a map of valid logging levels - collated from schema.
var LoggingEnum = map[string]bool{
	"critical": true,
	"warning":  true,
	"info":     true,
	"debug":    true,
	"detail":   true,
}

// isValidLoggingEnumCompare compares two values to determine if they are valid logging levels and if they are equal.
// It first converts the values to strings, then to lower case, and checks if they are valid logging levels.
// If both values are valid logging levels and are equal, it returns true; otherwise, it returns false.
//
// Parameters:
//   - s1: The first value to compare, of any type.
//   - s2: The second value to compare, of any type.
//
// Returns:
//   - bool: True if both values are valid logging levels and are equal, false otherwise.
func isValidLoggingEnumCompare(s1, s2 any) bool {
	str1, ok1 := toString(s1)
	str2, ok2 := toString(s2)

	if !ok1 || !ok2 {
		return false
	}

	str1Lower := strings.ToLower(str1)
	str2Lower := strings.ToLower(str2)

	return str1Lower == str2Lower && LoggingEnum[str1Lower]
}

func toString(value any) (string, bool) {
	str, ok := value.(string)
	return str, ok
}

func genMetaDataText(src, msg []byte, mdata map[string]string) ([]byte, error) {
	metaHeader := "# *** Aerospike Metadata Generated by Asconfig ***"

	err := metadata.Unmarshal(src, mdata)
	if err != nil {
		return nil, err
	}

	mtext, err := metadata.Marshal(mdata)
	if err != nil {
		return nil, err
	}

	metaFooter := "# *** End Aerospike Metadata ***"
	strMsg := string(msg)

	if len(msg) > 0 {
		strMsg += "\n#\n"
	}

	mtext = []byte(fmt.Sprintf("%s\n%s%s%s\n\n", metaHeader, strMsg, mtext, metaFooter))

	return mtext, nil
}

func getMetaDataItemOptional(src []byte, key string) (string, error) {
	mdata := map[string]string{}

	err := metadata.Unmarshal(src, mdata)
	if err != nil {
		return "", err
	}

	val := mdata[key]

	return val, nil
}

func getMetaDataItem(src []byte, key string) (string, error) {
	val, err := getMetaDataItemOptional(src, key)
	if err != nil {
		return "", err
	}

	if val == "" {
		return "", fmt.Errorf("%w: %s", errMetadataDoesNotContain, key)
	}

	return val, nil
}

// common flags.
func getCommonFlags() *pflag.FlagSet {
	res := &pflag.FlagSet{}
	res.StringP("aerospike-version", "a", "",
		"Aerospike server version to validate the configuration file for. Ex: 6.2.0.\n"+
			"The first 3 digits of the Aerospike version number are required.\n"+
			"This option is required unless --force is used.")

	return res
}

// getConfFileFormat guesses the format of an input config file
// based on file extension and the --format flag of the cobra command
// this function implements the defaults scheme for file formats in asconfig
// if the --format flag is defined use that, else if the path has an extension
// use that, else use the default value from --format.
func getConfFileFormat(path string, cmd *cobra.Command) (asConf.Format, error) {
	ext := filepath.Ext(path)
	ext = strings.TrimPrefix(ext, ".")

	fmtStr, err := cmd.Flags().GetString("format")
	if err != nil {
		return asConf.Invalid, err
	}

	logger.Debugf("Processing flag format value=%v", fmtStr)

	// if the user did not supply format, and
	// the input file has an extension, overwrite it with ext
	if !cmd.Flags().Changed("format") && ext != "" {
		fmtStr = ext
	}

	asFormat, err := ParseFmtString(fmtStr)
	if err != nil {
		return asConf.Invalid, err
	}

	return asFormat, nil
}

var ErrSilent = errors.New("SILENT")

func ParseFmtString(in string) (asConf.Format, error) {
	switch strings.ToLower(in) {
	case "yaml", "yml":
		return asConf.YAML, nil
	case "asconfig", "conf", "asconf":
		return asConf.AeroConfig, nil
	default:
		return asConf.Invalid, fmt.Errorf("%w: %s", asConf.ErrInvalidFormat, in)
	}
}
