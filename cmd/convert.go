package cmd

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	asConf "github.com/aerospike/aerospike-management-lib/asconfig"
	"github.com/spf13/cobra"

	"github.com/aerospike/asconfig/conf"
	"github.com/aerospike/asconfig/conf/metadata"
)

const (
	convertArgMax         = 1
	defaultOutputFileName = "config"
)

var (
	errTooManyArguments            = fmt.Errorf("expected a maximum of %d arguments", convertArgMax)
	errFileNotExist                = fmt.Errorf("file does not exist")
	errMissingAerospikeVersion     = fmt.Errorf("missing required flag '--aerospike-version'")
	errInvalidAerospikeVersion     = fmt.Errorf("aerospike version must be in the form <a>.<b>.<c>")
	errUnsupportedAerospikeVersion = fmt.Errorf("aerospike version unsupported")
	errInvalidFormat               = fmt.Errorf("invalid format flag")
	errMissingFormat               = fmt.Errorf("missing format flag")
)

func newConvertCmd() *cobra.Command {
	var cfgData []byte

	res := &cobra.Command{
		Use:   "convert [flags] <path/to/config_file>",
		Short: "Convert between yaml and Aerospike config format.",
		Long: `Convert is used to convert between yaml and aerospike configuration
				files. Input files are converted to their opposite format, yaml -> conf, conf -> yaml.
				The convert command validates the configuration file for compatibility with the Aerospike
				version passed to the --aerospike-version option, unless
				version metadata is present in the file or the --force option is used.
				Aerospike Database metadata is written to files generated by asconfig.
				Usage examples...
				convert local file "aerospike.yaml" to aerospike config format for version 6.2.0 and
				write it to local file "aerospike.conf."
				Ex: asconfig convert --aerospike-version "6.2.0" aerospike.yaml --output aerospike.conf
				Short form flags and source file only conversions are also supported.
				In this case, -a is the server version and using only a source file means
				the result will be written to stdout.
				Ex: asconfig convert -a "6.2.0" aerospike.yaml
				Normally the file format is inferred from file extensions ".yaml" ".conf" etc.
				Source format can be forced with the --format flag.
				Ex: asconfig convert -a "6.2.0" --format yaml example_file
				If a file path is not provided, asconfig reads the file contents from stdin.
				Ex: asconfig convert -a "6.4.0"
				If the file has been converted by asconfig before, the --aerospike-version option is not needed.
				Ex: asconfig convert -a "6.4.0" aerospike.yaml | asconfig convert --format conf`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return convertConfig(cmd, args, cfgData)
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return validateConvertPreRun(cmd, args, &cfgData)
		},
	} // flags and configuration settings
	// aerospike-version is marked required in this cmd's PreRun if the --force flag is not provided
	asCommonFlags := getCommonFlags()
	res.Flags().AddFlagSet(asCommonFlags)
	res.Flags().BoolP("force", "f", false, "Override checks for supported server version and config validation")
	res.Flags().StringP("output", "o", os.Stdout.Name(), "File path to write output to")
	res.Flags().StringP("format", "F", "conf", "The format of the source file(s). Valid options are: yaml, yml, and conf.")

	res.Version = VERSION

	return res
}

// convertConfig handles the main conversion logic.
func convertConfig(cmd *cobra.Command, args []string, cfgData []byte) error {
	logger.Debug("Running convert command")

	// read stdin by default
	var srcPath string
	if len(args) == 0 {
		srcPath = os.Stdin.Name()
	} else {
		srcPath = args[0]
	}

	asVersion, err := cmd.Flags().GetString("aerospike-version")
	if err != nil {
		return err
	}

	logger.Debugf("Processing flag aerospike-version value=%s", asVersion)

	force, err := cmd.Flags().GetBool("force")
	if err != nil {
		return err
	}

	logger.Debugf("Processing flag force value=%t", force)

	srcFormat, err := getConfFileFormat(srcPath, cmd)
	if err != nil {
		return err
	}

	logger.Debugf("Processing flag format value=%v", srcFormat)

	outFmt, err := determineOutputFormat(srcFormat)
	if err != nil {
		return err
	}

	// if the version option is empty, try populating from the metadata
	if asVersion == "" {
		asVersion, err = getMetaDataItem(cfgData, metaKeyAerospikeVersion)
		if err != nil && !force {
			return errors.Join(errMissingAerospikeVersion, err)
		}
	}

	// load, validate, and convert
	out, err := processConfigConversion(cfgData, srcFormat, outFmt, asVersion, force)
	if err != nil {
		return err
	}

	// write output
	return writeConvertedOutput(cmd, srcPath, outFmt, out)
}

// determineOutputFormat determines the output format based on source format.
func determineOutputFormat(srcFormat asConf.Format) (asConf.Format, error) {
	switch srcFormat {
	case asConf.AeroConfig:
		return asConf.YAML, nil
	case asConf.YAML:
		return asConf.AeroConfig, nil
	case asConf.Invalid:
		return asConf.Invalid, fmt.Errorf("%w: %s", errInvalidFormat, srcFormat)
	default:
		return asConf.Invalid, fmt.Errorf("%w: %s", errInvalidFormat, srcFormat)
	}
}

// processConfigConversion handles loading, validation, and conversion.
func processConfigConversion(cfgData []byte, srcFormat, outFmt asConf.Format, asVersion string, force bool) ([]byte, error) {
	// load
	asconfig, err := asConf.NewASConfigFromBytes(mgmtLibLogger, cfgData, srcFormat)
	if err != nil {
		return nil, err
	}

	// validate
	if !force {
		verrs, errValidate := conf.NewConfigValidator(asconfig, mgmtLibLogger, asVersion).Validate()
		if errValidate != nil || verrs != nil {
			return nil, errors.Join(errValidate, verrs)
		}
	}

	// convert
	out, err := conf.NewConfigMarshaller(asconfig, outFmt).MarshalText()
	if err != nil {
		return nil, err
	}

	// prepend metadata to the config output
	mtext, err := genMetaDataText(
		cfgData,
		nil,
		map[string]string{
			metaKeyAerospikeVersion: asVersion,
			metaKeyAsconfigVersion:  VERSION,
		},
	)
	if err != nil {
		return nil, err
	}

	return append(mtext, out...), nil
}

// writeConvertedOutput handles writing the converted output to file or stdout.
func writeConvertedOutput(cmd *cobra.Command, srcPath string, outFmt asConf.Format, out []byte) error {
	outputPath, err := cmd.Flags().GetString("output")
	if err != nil {
		return err
	}

	outputPath, err = determineOutputPath(outputPath, srcPath, outFmt)
	if err != nil {
		return err
	}

	var outFile *os.File
	if outputPath == os.Stdout.Name() {
		outFile = os.Stdout
	} else {
		outFile, err = os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, outputFilePermissions)
		if err != nil {
			return err
		}
		defer outFile.Close()
	}

	logger.Debugf("Writing converted data to: %s", outputPath)

	_, err = outFile.Write(out)

	return err
}

// determineOutputPath determines the final output path, handling directory outputs.
func determineOutputPath(outputPath, srcPath string, outFmt asConf.Format) (string, error) {
	if stat, err := os.Stat(outputPath); !errors.Is(err, os.ErrNotExist) && stat.IsDir() {
		// output path is a directory so write a new file to it
		outFileName := filepath.Base(srcPath)
		if srcPath == os.Stdin.Name() {
			outFileName = defaultOutputFileName
		}

		outFileName = strings.TrimSuffix(outFileName, filepath.Ext(outFileName))
		outputPath = filepath.Join(outputPath, outFileName)

		if outFmt == asConf.YAML {
			outputPath += ".yaml"
		} else if outFmt == asConf.AeroConfig {
			outputPath += ".conf"
		} else {
			return "", fmt.Errorf("output format unrecognized %w", errInvalidFormat)
		}
	}

	return outputPath, nil
}

// validateConvertPreRun handles pre-run validation logic.
func validateConvertPreRun(cmd *cobra.Command, args []string, cfgData *[]byte) error {
	if len(args) > convertArgMax {
		return errTooManyArguments
	}

	if len(args) > 0 {
		source := args[0]
		if _, err := os.Stat(source); errors.Is(err, os.ErrNotExist) {
			return errors.Join(errFileNotExist, err)
		}
	}

	// validate flags
	_, err := cmd.Flags().GetString("output")
	if err != nil {
		return err
	}

	force, err := cmd.Flags().GetBool("force")
	if err != nil {
		return err
	}

	return validateAerospikeVersion(cmd, args, force, cfgData)
}

// validateAerospikeVersion handles aerospike version validation.
func validateAerospikeVersion(cmd *cobra.Command, args []string, force bool, cfgData *[]byte) error {
	// read stdin by default
	var srcPath string
	if len(args) == 0 {
		srcPath = os.Stdin.Name()
	} else {
		srcPath = args[0]
	}

	data, err := os.ReadFile(srcPath)
	if err != nil {
		return err
	}

	*cfgData = data

	metaData := map[string]string{}
	if errUnmarshal := metadata.Unmarshal(*cfgData, metaData); errUnmarshal != nil {
		return errUnmarshal
	}

	// if the aerospike server version is in the cfg file's metadata, don't mark --aerospike-version as required
	var aeroVersionRequired bool

	if _, ok := metaData[metaKeyAerospikeVersion]; !ok {
		if !force {
			if err = cmd.MarkFlagRequired("aerospike-version"); err != nil {
				logger.Errorf("Unable to mark aerospike-version flag required: %v", err)
				return err
			}

			aeroVersionRequired = true
		}
	}

	if aeroVersionRequired {
		av, errFlag := cmd.Flags().GetString("aerospike-version")
		if errFlag != nil {
			return errFlag
		}

		if av == "" {
			return errors.Join(errMissingAerospikeVersion, err)
		}

		supported, errSupported := asConf.IsSupportedVersion(av)
		if errSupported != nil {
			return errors.Join(errInvalidAerospikeVersion, errSupported)
		}

		// TODO include valid versions in the error message
		// asconfig lib needs a getSupportedVersions func
		if !supported {
			return errUnsupportedAerospikeVersion
		}
	}

	formatString, err := cmd.Flags().GetString("format")
	if err != nil {
		return errors.Join(errMissingFormat, err)
	}

	_, err = ParseFmtString(formatString)
	if err != nil && formatString != "" {
		return errors.Join(errInvalidFormat, err)
	}

	return nil
}
